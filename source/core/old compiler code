scanTokens()
  //Use the scanner to build a token list for each user function
  {
    var currToken, prevToken, tokens;
    var inFunc = false;
    var inStructDef = false;

    this.rootUserFunc = new ObjUserFunc("<root>");
    this.vm.userFuncs.push(this.rootUserFunc);
    tokens = this.rootUserFunc.tokens;

    do
    {
      currToken = this.scanner.scanToken();

      switch(currToken.type)
      {


        case TOKEN_FUNCTION:
          if(inFunc)
            this.raiseError("Cannot have nested functions.", currToken);

          if(inStructDef)
            this.raiseError("Cannot have functions within structures.", currToken);

          currToken = this.scanner.scanToken();

          if(currToken.type != TOKEN_IDENTIFIER)
            this.raiseError("Expected identifier after 'function'.", currToken);

          if(this.getNativeFuncIndex(currToken.lexeme) != -1)
            this.raiseError("'" + currToken.lexeme + "' is already a function.", currToken);

          if(this.getUserFuncIndex(currToken.lexeme) != -1)
            this.raiseError("'" + currToken.lexeme + "' is already a function.", currToken);

          if(this.getStructDefIndex(currToken.lexeme) != -1)
            this.raiseError("'" + currToken.lexeme + "' is already a structure.", currToken);

          this.vm.userFuncs.push(new ObjUserFunc(currToken.lexeme));
          tokens = this.vm.userFuncs[this.vm.userFuncs.length - 1].tokens;
          inFunc = true;
          break;

        case TOKEN_STRUCTURE:
          if(inStructDef)
            this.raiseError("Cannot have nested structures.", currToken);

          if(inFunc)
            this.raiseError("Cannot have structures within functions.", currToken);

          currToken = this.scanner.scanToken();

          if(currToken.type != TOKEN_IDENTIFIER)
            this.raiseError("Expected identifier after 'structure'.", currToken);

          if(this.getNativeFuncIndex(currToken.lexeme) != -1)
            this.raiseError("'" + currToken.lexeme + "' is already a function.", currToken);

          if(this.getUserFuncIndex(currToken.lexeme) != -1)
            this.raiseError("'" + currToken.lexeme + "' is already a function.", currToken);

          if(this.getStructDefIndex(currToken.lexeme) != -1)
            this.raiseError("'" + currToken.lexeme + "' is already a structure.", currToken);

          this.vm.structDefs.push(new ObjStructureDef(currToken.lexeme));
          tokens = this.vm.structDefs[this.vm.structDefs.length - 1].tokens;
          inStructDef = true;
          break;


        case TOKEN_END:
          prevToken = currToken;
          currToken = this.scanner.scanToken();

          if(currToken.type == TOKEN_FUNCTION)
          {
            if(!inFunc)
              this.raiseError("'end function' without 'function'.", currToken);

            tokens.push(this.scanner.makeEOFToken());
            tokens = this.rootUserFunc.tokens;
            inFunc = false;
          }
          else if(currToken.type == TOKEN_STRUCTURE)
          {
            if(!inStructDef)
              this.raiseError("'end structure' without 'structure'.", currToken);

            tokens.push(this.scanner.makeEOFToken());
            tokens = this.rootUserFunc.tokens;
            inStructDef = false;
          }
          else
          {
            tokens.push(prevToken);
            tokens.push(currToken);
          }
          break;

        default:
          tokens.push(currToken);
      }
    }
    while(currToken.type != TOKEN_EOF)

    if(inFunc)
      this.raiseError("'function' without 'end function'.", tokens[0]);

    if(inStructDef)
      this.raiseError("'structure' without 'end structure'.", tokens[0]);
  }

  parseStructDefs()
  //
  {
    for(var structDefIndex = 0; structDefIndex < this.vm.structDefs.length; structDefIndex++)
    {
      this.currTokens = this.vm.structDefs[structDefIndex].tokens;

      if(!this.matchTerminator())
        this.raiseError("Expected terminator.");

      while(!this.endOfTokens())
      {
        if(!this.matchToken(TOKEN_IDENTIFIER))
          this.raiseError("Expected identifier.");

        this.vm.structDefs[structDefIndex].fieldIdents.push(this.peekPrevToken().lexeme);

        if(!this.matchTerminator())
          this.raiseError("Expected terminator after identifier.");
      }

      this.currTokens.splice(0);
      this.currTokenIndex = 0;
    }
  }

  parseUserFuncs()
  //
  {
    for(var funcIndex = 0; funcIndex < this.vm.userFuncs.length; funcIndex++)
    {
      this.currUserFunc = this.vm.userFuncs[funcIndex];
      this.currTokens = this.currUserFunc.tokens;

      if(this.currUserFunc != this.rootUserFunc)
        this.parseParameters();

      while(!this.endOfTokens())
        this.parseStatement();

      this.addReturnOps();
      this.currTokens.splice(0);
      this.currTokenIndex = 0;
    }
  }